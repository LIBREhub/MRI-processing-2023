var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The first thing you should do is to install it the latest version of Julia can be downloaded at the Julia Downloads page. It is advisable you add julia to the PATH, which can be done during the installation process.","category":"page"},{"location":"getting-started/#Installing-KomaMRI","page":"Getting Started","title":"Installing KomaMRI","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once Julia is installed, open the Julia REPL, and add the KomaMRI package by typing the following commands:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Press the ] key and then press enter to bring up Julia's package manager.\nType add KomaMRI and then press enter in the package manager session.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This process should take a while. Here is how it looks in the Julia REPL:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n\n(@v1.9) pkg> add KomaMRI","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Then press Ctrl+C or backspace to return to the julia> prompt.","category":"page"},{"location":"fundamentals-of-the-mri-signal/#Fundamentals-of-the-MRI-Signal","page":"Fundamentals of the MRI Signal","title":"Fundamentals of the MRI Signal","text":"","category":"section"},{"location":"simulation/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"This section delves into some details about how a sequence is constructed. The sequence definition in KomaMRI is strongly related to the Pulseq definition. After reading this section, you should be able to create your own Sequence structs for conducting custom simulations using the KomaMRI package.","category":"page"},{"location":"simulation/#Sequence-Overview","page":"Simulation","title":"Sequence Overview","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Let's introduce the following simple sequence figure to expand from a visual example to a more general sequence definition:","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"<p align=\"center\"><img width=\"80%\" src=\"../assets/sequence-diagram.svg\"/></p>","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"A sequence can be thought of as an ordered concatenation of blocks over time. Each block is essentially a sequence with a length of 1. Every block consists of an RF pulse, the (xyz) gradients, and the acquisition of samples. Each block also has an associated time duration. To simplify, we will refer to these components as follows:","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"beginmatrix*l\ntextseqi        textblock i of the sequence \ntextseqRFi     textRF pulse at the i block \ntextseqGRxi   textgradient x at the i block \ntextseqGRyi   textgradient y at the i block \ntextseqGRzi   textgradient z at the i block \ntextseqADCi    textacquisition at the i block \ntextseqDURi    textduration at the i block\nendmatrix*","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"The best way to understand the Sequence struct in KomaMRI is by examining the source code where this struct is defined:","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"mutable struct Sequence\n    GR::Array{Grad,2}\n    RF::Array{RF,2}\n    ADC::Array{ADC,1}\n    DUR::Array{Any,1}\n    DEF::Dict{String,Any}\nend","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"As you can see, a Sequence struct contains 5 field names: ''DEF'' contains information for reconstruction steps (so it is not mandatory to fill it), ''DUR'' is a vector that contains the time durations of each block, ''ADC'' is also a vector with the acquisition samples for every block (an vector of ADC structs), ''GR'' is a 2D matrix which 3 rows representing the x-y-z gradients and columns having the samples of each block (a matrix of Grad structs) and ''RF'' is also a 2D matrix where each row represents a different coil and the columns are for different block samples too (a matrix of RF structs). The RF, Grad and ADC are MRI events that will be explained in the section Events Definitions.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"warning: Warning\nSo far, KomaMRI can only manage one coil for RF excitations. However, in future versions, multiple coils will be managed by adding more ``rows'' to the RF matrix of the Sequence field name.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"In order to understand how a Sequence struct can be manipulated in Julia, let's use the EPI sequence example. You can display basic information of the Sequence variable in the Julia REPL:","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"julia> seq = PulseDesigner.EPI_example()\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 5 ]","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"As you can see, this Sequence has 204 blocks, 1 of these blocks has an RF struct with values different from zero, there are 205 number of Grad structs considering the x-y-z components, 101 ADC structs acquire samples of some blocks and 62.846 ms is the total time duration of the complete Sequence.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"To display the sequence in an graph, we can use the plot_seq() function:","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"julia> plot_seq(seq)","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"<object type=\"text/html\" data=\"../assets/seq-epi-example-full.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"This way, you can see exactly where the RF, Grad and ADC structs are located in time.","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"You can access and filter information for the RF, Grad, ADC, and DUR field names of a Sequence using the dot notation. This allows you to display helpful information about the organization of the Sequence struct:","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"julia> seq.RF\n1×204 Matrix{RF}:\n ⊓(0.5872 ms)  ⇿(0.0 ms)  ⇿(0.0 ms)  …  ⇿(0.0 ms)  ⇿(0.0 ms)   \n\njulia> seq.GR\n3×204 Matrix{Grad}:\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⊓(0.4042 ms)  …  ⇿(0.2062 ms)  ⊓(0.4042 ms)  ⊓(0.4042 ms)\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⇿(0.4042 ms)     ⊓(0.2062 ms)  ⇿(0.4042 ms)  ⊓(0.4042 ms)\n ⇿(0.5872 ms)  ⇿(0.0 ms)     ⇿(0.0 ms)        ⇿(0.0 ms)     ⇿(0.0 ms)     ⇿(0.0 ms)\n\njulia> seq.ADC\n204-element Vector{ADC}:\n ADC(0, 0.0, 0.0, 0.0, 0.0)\n ADC(0, 0.0, 0.0, 0.0, 0.0)\n ADC(101, 0.00019999999999999998, 0.00010211565434713023, 0.0, 0.0)\n ⋮\n ADC(101, 0.00019999999999999998, 0.00010211565434713023, 0.0, 0.0)\n ADC(0, 0.0, 0.0, 0.0, 0.0)\n\njulia> seq.DUR\n204-element Vector{Float64}:\n 0.0005871650124959989\n 0.0004042313086942605\n 0.0004042313086942605\n ⋮\n 0.0004042313086942605\n 0.0004042313086942605","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Additionally, you can access a subset of blocks in a Sequence by slicing or indexing. The result will also be a Sequence struct, allowing you to perform the same operations as you would with a full Sequence. For example, if you want to analyze the first 11 blocks, you can do the following:","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"julia> seq[1:11]\nSequence[ τ = 3.837 ms | blocks: 11 | ADC: 5 | GR: 11 | RF: 1 | DEF: 5 ]\n\njulia> seq[1:11].GR\n3×11 Matrix{Grad}:\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⊓(0.4042 ms)   …  ⊓(0.4042 ms)  ⇿(0.2062 ms)  ⊓(0.4042 ms)\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⇿(0.4042 ms)      ⇿(0.4042 ms)  ⊓(0.2062 ms)  ⇿(0.4042 ms)\n ⇿(0.5872 ms)  ⇿(0.0 ms)     ⇿(0.0 ms)        ⇿(0.0 ms)     ⇿(0.0 ms)     ⇿(0.0 ms)\n\njulia> plot_seq(seq[1:11])","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"<object type=\"text/html\" data=\"../assets/seq-epi-example-some-blocks.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"simulation/#Concatenation-of-Sequences","page":"Simulation","title":"Concatenation of Sequences","text":"","category":"section"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"Sequences can be concatenated side by side. The example below demonstrates how to concatenate sequences:","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"julia> s = PulseDesigner.EPI_example()[1:11]\nSequence[ τ = 3.837 ms | blocks: 11 | ADC: 5 | GR: 11 | RF: 1 | DEF: 5 ]\n\njulia> seq = s + s + s\nSequence[ τ = 11.512 ms | blocks: 33 | ADC: 15 | GR: 33 | RF: 3 | DEF: 5 ]\n\njulia> plot_seq(seq)","category":"page"},{"location":"simulation/","page":"Simulation","title":"Simulation","text":"<object type=\"text/html\" data=\"../assets/seq-concatenation.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"parallel-imaging/#Parallel-Imaging","page":"Parallel Imaging","title":"Parallel Imaging","text":"","category":"section"},{"location":"quantitative-mapping/#Quantitative-Mapping","page":"Quantitative Mapping","title":"Quantitative Mapping","text":"","category":"section"},{"location":"compress-sensing/#Compress-Sensing","page":"Compress Sensing","title":"Compress Sensing","text":"","category":"section"},{"location":"#MRI:-Procesando-tus-datos","page":"Home","title":"MRI: Procesando tus datos","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CC BY 4.0) (Image: Open Source Love)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bienvenido/a al repositorio del taller práctico presencial \"MRI: Procesando tu datos\" que se realiza los días 20 y 21 de Noviembre de 2023 en el Campus San Joaquin de la Pontificia Universidad Católica de Chile.","category":"page"},{"location":"","page":"Home","title":"Home","text":"En este repositorio encontrarás información, datos y cuadernos de trabajos relacionados al taller práctico.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Este repositorio esta licenciado abiertamente por Pablo Irrarázaval, Guillermo Sahonero, Boris Oróstica y Pierre Padilla, basándose en Creative Commons Attribution 4.0 International License","category":"page"},{"location":"","page":"Home","title":"Home","text":"Este es el enlace a la página web del curso: https://librehub.github.io/MRI-processing-2023/ renderizado desde este repositorio.","category":"page"},{"location":"#Reconocimientos","page":"Home","title":"Reconocimientos","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Nos gustaría agradecer a Chan Zuckerberg Initiative, a través del proyecto LIBRE hub, por el soporte financiero y a la Pontificia Universidad Católica de Chile, a través del Instituto de Ingeniería Biológica y Médica, por facilitar el uso de sus instalaciones para el curso.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: img.png)","category":"page"},{"location":"off-resonance-correction/#Off-Resonance-Correction","page":"Off-Resonance Correction","title":"Off-Resonance Correction","text":"","category":"section"},{"location":"basic-signal-processing/#Basic-Signal-Processing","page":"Basic Signal Processing","title":"Basic Signal Processing","text":"","category":"section"}]
}
